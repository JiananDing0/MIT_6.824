# Lecture 4: Primary Backup Replication

#### Introduction to VMware FT(Fault tolerance):
* A common approach to implementing fault-tolerant servers is called primary/backup approach, where a backup server is always available to take over if the primary server fails.
  - Notice that replication cannot always recovers all type of problems. For some problems such as the primary server stops execution, the replication approach can always deal with it. However, when it comes to problems such as design defect or bugs in software, the replication approach does not work well. *In this case, we may try something to change those type of mistakes into a stop execution, then reboot to solve it. But it does not always work.*
* One possible approach to do this using comparably low bandwidth is the deterministic state machine approach. The idea is to model the servers as deterministic state machines that are kept in sync by starting them from the same initial state and ensuring that they receive the same input requests in the same order.
* **Hypervisor**: apply of hypervisor can effectively ensure the determinism. Because the hypervisor emulates and controls many aspects of the hardware that might differ between primary and backup executions, for example the precise timing of interrupt delivery, which resolve some possible undeterministic operations.
  - Traditional system architecture: one OS per physical server and one application per OS.
  - VMware architecture: one hypervisor per physical server to support multiple unique and isolated virtual machines(including OS and application) to run on top of the **same hypervisor**.
* Common questions need to be considered:
  - What state needs to be replicated?  
    * According to the paper, VMware FT provided the full copy of all registers and memory as a state of a single server. It will duplicate the whole state to the backup server whenever it is necessary.
  - How to keep the syncroniization between primary and backup server?  
    * The solution is actually straightforward and concluded in **Section 2.1: Deterministic replay implementation**. Based on the fact that most of the computer instructons, such as add, read, write or others, will come up with a deterministic result for sure, the primary server can send those instructions to the backup server directly to keep the syncronization between them. In terms of undeterministic instructions, the backup server will not execute those by itself, but wait for primary server to provide the result state after executing those inistructions. 
    * The steam between the primary and backup is called **logging channel**, and each instruction will be stored in a structure called **logging entry**, which contains information such as the instruction number and corresponding content, or result for undeterministic instructions. In theory, the backup server will receive large number of logging entries per second. As a result, when it detects no entries from primary, the backup knows that the primmary might be dead.
  - How do we deal with unexpected cut-off?
    * One unexpected coondition is when the primary server complete executing a package and send the output to the clients, the primary is down and the communication between the primary and backup also broken at the same time. In this case, the backup will have no idea about the package been executed by the primary server, which may cause errors. In order to get rid of this case, the primary server will not reply to the clients until it ensures that the instructions in this package has been received by the backup server.
  - How is bounce buffer help with race conditions? (Reference from [FAQ](https://pdos.csail.mit.edu/6.824/papers/vm-ft-faq.txt))
    * The problem arises when a network packet or requested disk block arrives at the primary and needs to be copied into the primary's memory. Without FT, the relevant hardware copies the data into memory while software is executing. Guest instructions could read that memory during the DMA; depending on exact timing, the guest might see or not see the DMA'd data (this is the race). It would be bad if the primary and backup both did this, but due to slight timing differences one read just after the DMA and the other just before. In that case they would diverge.
    * FT avoids this problem by not copying into guest memory while the primary or backup is executing. FT first copies the network packet or disk block into a private "bounce buffer" that the primary cannot access. When this first copy completes, the FT hypervisor interrupts the primary so that it is not executing. FT records the point at which it interrupted the primary (as with any interrupt). Then FT copies the bounce buffer into the primary's memory, and after that allows the primary to continue executing. FT sends the data to the backup on the log channel. The backup's FT interrupts the backup at the same instruction as the primary was interrupted, copies the data into the backup's memory while the backup is into executing, and then resumes the backup.
    * The effect is that the network packet or disk block appears at exactly the same time in the primary and backup, so that no matter when they read the memory, both see the same data.
